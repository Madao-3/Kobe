<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <title>Kobe by Madao-3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  <style type="text/css" media="screen">
/*  body{background:#000;};*/
  canvas{
    position: absolute;
    top: 0%;
    left: 0;
    width: 100%;
    height: 100%;
  }
  </style>
</head>
<body>
  <canvas id="main_container"></canvas>
	<script src="./genetic-0.1.14.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script>
  window.current = 0
  window.container_ctx = $('#main_container').get(0).getContext("2d")
  window.item_size = 10
  window.rows_count = 0
  window.prev_result = null
  function create_genetic(index){
    var genetic = Genetic.create();
    genetic.optimize = Genetic.Optimize.Maximize;
    genetic.select1 = Genetic.Select1.Fittest;
    genetic.select2 = Genetic.Select2.RandomLinearRank;
    // 种子RBG 色彩字符串
    genetic.seed = function() {
      var RGB_CONSTANTS_NUMBER = 256
      function randomRGBItem() {
        return Math.floor(Math.random()*RGB_CONSTANTS_NUMBER)
      }
      function randomRGBColor() {
        return [randomRGBItem(),randomRGBItem(),randomRGBItem()];
      }
      return randomRGBColor();
    };

    // 变异，修改色值完成进化  
    // 注：色值修改不涉及逗号的部分，只进行数字部分的修改
    genetic.mutate = function(entity) {
      if (this.userData.prev_result) {
        entity = this.userData.prev_result
        this.userData.prev_result = null
      } else {
        var RGB_CONSTANTS_NUMBER = 256
        var index = Math.floor(Math.random()*entity.length)
        entity[index] = Math.floor(entity[index] + RGB_CONSTANTS_NUMBER * Math.random())%RGB_CONSTANTS_NUMBER
      }
      return entity
    };
    // 交叉 遗传算法的基因重组
    // 
    genetic.crossover = function(mother, father) {
      // two-point crossover
      var len = mother.length;
      var ca = Math.floor(Math.random()*len);
      var cb = Math.floor(Math.random()*len);		
      if (ca > cb) {
        var tmp = cb;
        cb = ca;
        ca = tmp;
      }
		
      var son      = father.slice(0,ca).concat(mother.slice(ca, cb-ca).concat(father.slice(cb,len)))
      var daughter = mother.slice(0,ca).concat(father.slice(ca, cb-ca).concat(mother.slice(cb,len)))
	
      return [son, daughter];
    };
    genetic.fitness = function(entity) {
      var fitness = 0;
	
      var i;
      for (i=0;i<entity.length;++i) {
        // increase fitness for each character that matches
        // console.log(this.userData["solution"][i],'hahaha2')
        if (entity[i] == this.userData["solution"][i])
          fitness += 1;
        // award fractions of a point as we get warmer
        fitness += (127-Math.abs(entity[i] - this.userData["solution"][i]))/50;
      }

      return fitness;
    }
    
    genetic.generation = function(pop, generation, stats) {
      // stop running once we've reached the solution
      // console.log(this.userData["solution"],'hehe1')
      // console.log(pop[0].entity.join(',') == this.userData["solution"].join(','),'test')
      var value = []
      // console.log(this.userData,pop[0].entity)
      for (var i in this.userData["solution"]) {
        var v = this.userData["solution"][i]
        value.push(v)
      }
      return pop[0].entity.join(',') != value.join(',');
    }
    
    genetic.notification = function(pop, generation, stats, isFinished) {
      var value = pop[0]
    	if (pop != 0 && value == this.last)
    		return;
      // console.log(value)
      x = (window.current%window.rows_count)*window.item_size
      y = parseInt(window.current/window.rows_count,10)*window.item_size
      
      if (isFinished) {
        // console.log("finish!!!!!current index",window.current)
        // window.prev_result = value.entity
        // window.current++;
        // create_genetic(window.current)
        // window.container_ctx.fillStyle="rgb("+value.entity.join(',')+")";
        // window.container_ctx.fillRect(x,y,window.item_size,window.item_size);
        
        // $("body").prepend("<p style='color:red'>"+value.entity.join(',')+"|generation|"+generation+"</p>");
      } else {
        window.container_ctx.fillStyle="rgb("+value.entity.join(',')+")";
        window.container_ctx.fillRect(x,y,window.item_size,window.item_size);
      }
    }
    
    if (window.result[index]) {
      var userData = {
        "solution"  : window.result[index]
      }
      console.log(window.result[index])
      if (window.prev_result) {
        userData.prev_result = window.prev_result
      }
  		var config = {
  			"iterations": 4000,
        "size": 250,
        "crossover": 0.3,
        "mutation": 0.3,
        "skip": 20
  		}
      genetic.evolve(config, userData);
    }
  }
  
  function start_patch() {
    // console.log('start_path current index!!!!',window.current)
    // for (var i = 0; i < 4; i++) {
      create_genetic(window.current)
    // }
  }
  window.result = []

  $(document).ready(function () {

    image = new Image()
    image.src = './kobe1.jpg'
    image.onload = function(){
      var image = this,
      x  = y = 0,
      width  = image.width,
      height = image.height,
      window_width = $(window).width(),
      canvas = document.createElement('canvas'),
      context = canvas.getContext('2d')
      context.drawImage(image, y, x)
      var imageData = context.getImageData(x, y, width, height);
      var data = imageData.data;
      window.data = data
      rows = Math.floor(width / 16,10)
      cols = Math.floor(height / 16,10)
      canvas_height = (height/width)*window_width

      window.item_size  = 20
      window.rows_count = rows
      
      $('#main_container').attr({
        width: window.item_size*rows,
        height: cols*window.item_size
      })
      
      i = 0
      window.full_list = []
      while(i != data.length) {
        next = i + 4
        window.full_list.push(data.slice(i,next-1 ))
        i = next
      }
      
      for (var i = 0; i < cols; i++) {
        for (var j = 0; j < rows; j++) {
          index = (rows*32)*i+j*16
          data = full_list[index]
          if (data) {
            window.result.push(data)
          }
        }
      }
      start_patch()
    }
  });

  </script>
	
	
</body>
</html>