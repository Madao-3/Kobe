<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <title>Kobe by Madao-3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
</head>
<body>
	<script src="./genetic-0.1.14.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script>
  window.current = 0
  function create_genetic(index){
    var genetic = Genetic.create();
    genetic.optimize = Genetic.Optimize.Maximize;
    genetic.select1 = Genetic.Select1.Fittest;
    genetic.select2 = Genetic.Select2.RandomLinearRank;
    // 种子RBG 色彩字符串
    genetic.seed = function() {
      var RGB_CONSTANTS_NUMBER = 256
      function randomRGBItem() {
        return Math.floor(Math.random()*RGB_CONSTANTS_NUMBER)
      }
      function randomRGBColor() {
        return [randomRGBItem(),randomRGBItem(),randomRGBItem()];
      }
      return randomRGBColor();
    };

    // 变异，修改色值完成进化  
    // 注：色值修改不涉及逗号的部分，只进行数字部分的修改
    genetic.mutate = function(entity) {
      var RGB_CONSTANTS_NUMBER = 256
      index = Math.floor(Math.random()*entity.length)
      entity[index] = Math.floor(entity[index] + RGB_CONSTANTS_NUMBER * Math.random())%RGB_CONSTANTS_NUMBER
      return entity
    };
    // 交叉 遗传算法的基因重组
    // 
    genetic.crossover = function(mother, father) {
      // two-point crossover
      var len = mother.length;
      var ca = Math.floor(Math.random()*len);
      var cb = Math.floor(Math.random()*len);		
      if (ca > cb) {
        var tmp = cb;
        cb = ca;
        ca = tmp;
      }
		
      var son      = father.slice(0,ca).concat(mother.slice(ca, cb-ca).concat(father.slice(cb,len)))
      var daughter = mother.slice(0,ca).concat(father.slice(ca, cb-ca).concat(mother.slice(cb,len)))
	
      return [son, daughter];
    };
    genetic.fitness = function(entity) {
      var fitness = 0;
	
      var i;
      for (i=0;i<entity.length;++i) {
        // increase fitness for each character that matches
        if (entity[i] == this.userData["solution"][i])
          fitness += 1;
        // award fractions of a point as we get warmer
        fitness += (127-Math.abs(entity[i] - this.userData["solution"][i]))/50;
      }

      return fitness;
    };
    genetic.generation = function(pop, generation, stats) {
      // stop running once we've reached the solution
      return pop[0].entity != this.userData["solution"];
    };
    genetic.notification = function(pop, generation, stats, isFinished) {
      console.log(pop,generation)
      if (isFinished) {
        window.current++;
        if (window.current%4) {
          
        }
      }
    }
    
    var userData = {
      "solution"  : self.result[index]
    };
    genetic.evolve(config, userData);
  }
  
  function start_patch() {
    for (var i = 0; i < 5; i++) {
      create_genetic(window.current+i)
    }
  }
  window.result = []

  $(document).ready(function () {

    image = new Image()
    image.src = './kobe.jpg'
    image.onload = function(){
      var x  = y = 0,
      width  = this.width,
      height = this.height,
      canvas = document.createElement('canvas'),
      context = canvas.getContext('2d')
      context.drawImage(this, y, x)
      var imageData = context.getImageData(x, y, width, height);
      var data = imageData.data;
      i = 0
      while(i != data.length) {
        next = i + 3
        window.result.push(data.slice(i,next))
        i = next
      }
      start_patch()
    }
    

  });

  </script>
	
	
</body>
</html>